import java.awt.Point;
import java.util.*;
import world.*;

public class RobotTravel extends Robot{
	Point start;
	Point destination;
	boolean uncertainty;
	int cols;
	int rows;
	Queue<Coordinate> coordinates;
	int[][] map;
	Map<Point, Point> cameFrom;
	public RobotTravel(Point st, Point dest, boolean u) {
		super();
		start = st;
		destination = dest;
		uncertainty = u;
		coordinates = new LinkedList<Coordinate>();
		map = new int[rows][cols];
	}
	
	@Override
	public void travelToDestination() {
		if (!uncertainty) {
			AStar(start, destination);
			
		}
		else {
			
		}
	}

	public int getCols() {
		return cols;
	}

	public void setCols(int cols) {
		this.cols = cols;
	}

	public int getRows() {
		return rows;
	}

	public void setRows(int rows) {
		this.rows = rows;
	}
	
	public void AStar(Point st, Point go) {
		
		List<Point> evaluated = new LinkedList<Point>();
		List<Point> notEvaluated = new LinkedList<Point>();
		notEvaluated.add(st);
		cameFrom = new HashMap<Point, Point>();
		
		Map<Point, Double> gScore = new HashMap<Point, Double>();
		
		//Put default value of positive infinity into map
		for (int i = 0; i < rows; i++) { //x axis
			for (int j = 0; j < cols; j++) { //y axis
				gScore.put(new Point(i, j), Double.POSITIVE_INFINITY);
			}
		}
		gScore.put(st, 0.0);
		System.out.println("gScores: " + gScore.toString());
		
		Map<Point, Double> fScore = new HashMap<Point, Double>();
		//Put default value of positive infinity into map
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {
				fScore.put(new Point(i, j), Double.POSITIVE_INFINITY);
			}
		}		
		fScore.put(st, heuristic(st, go));
		System.out.println("fScores: " + fScore.toString());
		
		//Switch != and == to turn loop on and off
		while (notEvaluated.isEmpty() == false) {
			//System.out.println(notEvaluated.toString());
			System.out.println("----------------------------------------------------------------");
			System.out.println("Start: " + st.toString());
			double lowestCurrentScore = Collections.min(fScore.values());
			Point current = (Point) getKeyFromValue(fScore, lowestCurrentScore);
			System.out.println("Lowest current fScore: " + lowestCurrentScore);
			System.out.println("fScores: " + fScore.toString());
			//current.equals(destination)
			if ((int) current.getX() == (int) go.getX() && (int) current.getY() == (int) go.getY()) {
				reconstructPath(cameFrom, go);
				return;
			}
			if (notEvaluated.contains(current)) notEvaluated.remove(current);
			if (!evaluated.contains(current)) evaluated.add(current);
			System.out.println("Current: " + current.toString());
			
			//Generate adjacents
			List<Point> adj = new ArrayList<Point>();
			Point nw = new Point((int) current.getX() - 1, (int) current.getY() - 1);
			Point ne = new Point((int)current.getX() - 1, (int)current.getY() + 1);
			Point n = new Point((int)current.getX() - 1, (int)current.getY());
			Point w = new Point((int)current.getX(), (int)current.getY() - 1);
			Point sw = new Point((int)current.getX() + 1, (int)current.getY() - 1);
			Point s = new Point((int)current.getX() + 1, (int)current.getY());
			Point se = new Point((int)current.getX() + 1, (int)current.getY() + 1);
			Point ea = new Point((int)current.getX(), (int)current.getY() + 1);
			adj.add(nw); adj.add(ne); adj.add(n); adj.add(w);
			adj.add(sw); adj.add(s); adj.add(se); adj.add(ea);
			System.out.println("All adj before pinging: " + adj.toString());
			//Iterator<Point> i = adj.iterator(); i.hasNext();
			//for (int i = 0; i < adj.size(); i++) {
			Iterator<Point> i = adj.iterator();
			while (i.hasNext()) {
				//Point el = adj.get(i);
				Point el = i.next();
				if (super.pingMap(new Point((int)el.getX(), (int)el.getY())) == null) {
					System.out.println(el.toString());
					//adj.remove(el);
					//i--;
					i.remove();
				}
				else if (super.pingMap( new Point( (int)el.getX(), (int)el.getY() ) ) .equals("X")){
					System.out.println(el.toString());
					//adj.remove(el);
					//i--;
					i.remove();
				}
			} //Allowable adjacents fully generated
			System.out.println("Allowable adjacents fully generated.");
			System.out.println("Allowable adjacents: " + adj.toString());
			//Now, for each neighbor of adjacent
			double tentative_gScore;
			int counter = 0;
			for (Point neighbor: adj) {
				System.out.println(counter++);
				if (evaluated.contains(neighbor)) {
					System.out.println("Neighbor already evaluated!");
					//continue;
				}
				//tentative_gScore = gScore.get(current) + current.distance(neighbor);
				tentative_gScore = gScore.get(current) + heuristic(current, neighbor);
				System.out.println("Tentative gScore of " + neighbor.toString() + ": "+tentative_gScore);
				if (!notEvaluated.contains(neighbor)) {
					System.out.println("Neighbor added to notEvaluated.");
					notEvaluated.add(neighbor);
				}
				if (tentative_gScore >= gScore.get(neighbor)) {
					System.out.println("tentative_gScore >= neighbor gScore");
					//continue;
				}
				cameFrom.put(neighbor, current);
				gScore.put(neighbor, tentative_gScore);
				fScore.put(neighbor, gScore.get(neighbor) + heuristic(neighbor, go));
				System.out.println("fScore of neighbor: " + fScore.get(neighbor).toString());
			}
			System.out.println("Not Evaluated Nodes: " + notEvaluated.toString());
			System.out.println("Evaluated Nodes: " + evaluated.toString());
		}
		//return failure;
		return;
	}
	public List<Point> reconstructPath(Map<Point, Point> cameFrom, Point current) {
		List<Point> totalPath = new LinkedList<Point>();
		totalPath.append(current);
		
		return null;
	}
	
	//Modified Manhattan distance allowing for diagonal
	public Double heuristic(Point p, Point d) {
		double dx = Math.abs(p.getX() - d.getX());
		double dy = Math.abs(p.getY() - d.getY());
		//return dx + dy + (-1)*Math.min(dx, dy);
		return Math.max(dx, dy);
	}
//	public Double distBetween(Point current, Point neighbor) {
//		current.distance(neighbor);
//		return current.distance(neighbor);
//	}
	//Taken from Stackoverflow: 
	//http://stackoverflow.com/questions/1383797/java-hashmap-how-to-get-key-from-value/28415495#28415495
	public static Object getKeyFromValue(Map<Point, Double> hm, Object value) {
        for (Object o : hm.keySet()) {
          if (hm.get(o).equals(value)) {
            return o;
          }
        }
        return null;
    }
    
}

//Coordinate end = new Coordinate((int) destination.getX(), (int)destination.getY(), 0);
//coordinates.add(end);
//System.out.println(coordinates.element().toString());
//for (Coordinate e : coordinates) {
//	List<Coordinate> adj = new ArrayList<Coordinate>();
//	Coordinate nw = new Coordinate(e.getX() - 1, e.getY() - 1, e.getCounter() + 1);
//	Coordinate ne = new Coordinate(e.getX() - 1, e.getY() + 1, e.getCounter() + 1);
//	Coordinate n = new Coordinate(e.getX() - 1, e.getY(), e.getCounter() + 1);
//	Coordinate w = new Coordinate(e.getX(), e.getY() - 1, e.getCounter() + 1);
//	Coordinate sw = new Coordinate(e.getX() + 1, e.getY() - 1, e.getCounter() + 1);
//	Coordinate s = new Coordinate(e.getX() + 1, e.getY(), e.getCounter() + 1);
//	Coordinate se = new Coordinate(e.getX() + 1, e.getY() + 1, e.getCounter() + 1);
//	Coordinate ea = new Coordinate(e.getX(), e.getY() + 1, e.getCounter() + 1);
//	if (super.pingMap(new Point(nw.getX(), nw.getY())) != null) {
//		adj.add(nw);
//	}
//	if (super.pingMap(new Point(ne.getX(), ne.getY())) != null) {
//		adj.add(ne);
//	}
//	if (super.pingMap(new Point(n.getX(), n.getY())) != null) {
//		adj.add(n);
//	}
//	if (super.pingMap(new Point(w.getX(), w.getY())) != null) {
//		adj.add(w);
//	}
//	if (super.pingMap(new Point(sw.getX(), sw.getY())) != null) {
//		adj.add(sw);
//	}
//	if (super.pingMap(new Point(s.getX(), s.getY())) != null) {
//		adj.add(s);
//	}
//	if (super.pingMap(new Point(se.getX(), se.getY())) != null) {
//		adj.add(se);
//	}
//	if (super.pingMap(new Point(ea.getX(), ea.getY())) != null) {
//		adj.add(ea);
//	}
//	for (Coordinate el : adj) {
//		if (super.pingMap(new Point(el.getX(), el.getY())).equals("X")){
//			adj.remove(el);
//		}
//		for (Coordinate a: coordinates) {
//			if (a.getX() == el.getX() && a.getY() == el.getY()
//					&& a.getCounter() > el.getCounter()) {
//				adj.remove(el);
//				break;
//			}
//		}
//	}
//	for (Coordinate el : adj) {
//		coordinates.add(el);
//	}
//}
